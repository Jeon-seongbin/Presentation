1. 옵티마이저
sql을 실행할 최적의 경로를 생성해 주는 DBMS내부 엔진

2. 실행계획
sql을 실행할 때 옵티마이저가 수립하는 작업의 절차
테이블 검색할때 어떤 식으로 검색을 할건지 인덱스 스캔을 할건지 안할건지 그런거 보여줌

3. 인덱스
테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터 베이스 객체(object)
키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능
색인(책 뒤에 찾아보기 개념)
인덱스도 오브젝트이고 테이블과 매핑된 또다른 오브젝트가 생성된다
인덱스에서 먼저 해당 데이터를 찾은 다음에 실제 매핑된  테이블에 엑세스 해서 데이터들을 찾음

인덱스의 종류
비 트리 인덱스 보통 이것을 사용
비트맵 인덱스
iot 인덱스
클러스터 인덱스

클러스터 인덱스
영어사전같은 개념 (primary key 설정 시 자동으로 만들어짐)
정렬된 인덱스
범위 검색에 좋다 -> 영어사전 개념임
테이블 당 한개 생성

b tree인덱스
인덱스가 b tree 로 구성되어져 있음
루트블록 - 브랜치 블록 - 리프블록 구성으로 되어 있다
어느 데이터에 엑세스 해도, 일정한 시간만에 엑세스가 가능하며 가지 깊이가 영향을 주지는 않는다
범위 검색을 할 때에도, 가지에서 검색이 일어나기때문에 영향이 가지 않는다

b tree인덱스의 분할
인덱스에 중간 값이 추가가 되면 페이지에 공간이 남지 않아 분할이 발생하게 되고 이는 데이터베이스에 많은 영향을 준다

만약 로우가 지금까지 발생한 다음부터 들어가는 추가 형태 라면 분할을 발생시키지 않고 인덱스에 들어갈 수 있다.
컬럼속성(인덱스가)이 시퀀스나 발생일자 항목으로 구성되었다면 새로운 로우가 대량으로 삽입되더라도 분할은 발생 하지 않는다

중간에 들어오는 경우 2/3만 채우게 되므로 분할만 되고 사용하지 않는다면 저장공간 낭비가 된다
-> 이것을 교정하는 방법은 인덱스 재생성을 할 수 밖에 없다

b tree 구조에서 데이터 삭제 갱신이 일어날 때

데이터가'삭제' 될 때, 해당 로우는 제거되지만, '인덱스의 로우는 삭제플래그만 두기 때문'에
저장공간 낭비와 스캔할 데이터만 증가된다

이것은 비트리 인덱스의 루트를 찾을때에는 불필요한 일이 발생하지 않지만
범위처리를 할 때에는 삭제 플래그가되어있는 인덱스에도 엑세스를 하기 때문에 불필요한 처리가 증가될 수 있다.

'인덱스 컬럼을 구성하고 있는 컬럼 값에 갱신이 발생'하게 되면,  비트리 인덱스에서는 삭제 추가 처리가 발생하게 된다
이것은 인덱스 로우가 정렬되어 저장되어지기 때문에 어쩔 수 없이 발생하는 현상이다
수정이 빈번하지 않은 컬럼을 인덱스로 두어야 한다.

삭제나 갱신이 발생하더라도 언제나 과도하게 저장공간을 소비하게 되고, 트리구조의 깊이가 깊어진다
DML(갱신 삭제)처리가 많이 일어나는 테이블은 정기적으로 인덱스 재 구성을 할 필요가 있다







인덱스 저장방식은 인덱스 컬럼 기준으로 소팅이 되어서 생성됨
특정 조건의 시작점을 인덱스로 검색하여 거기서부터 검색 
인덱스는 해당 데이터 블록의 주소(ROWID)를 가지고있다


코딩 시 인덱스 활용 방법
특정 조건 즉 where 절에 등장하는 컬럼을 설정
order by -> 인덱스는 순차적으로 저장되기 때문에 
insert 나 update에서 속도가 느려질 수 있으므로 주의
순차적으로 입력된 데이터라서 그렇고
인덱스는 테이블과 매핑이 되어 있기 때문에 속도가 느릴 수 있다
인덱스 컬럼을 가공(함수이용)하면 인덱스를 사용안한다
인덱스 컬럼의 형변환 하면 인덱스를 사용 안한다 (같은 타입으로 비교)
null값에 대해서 찾는것도 인덱스를 사용 안한다
like연산 시 %가 앞에 위치한것
부정형 비교 != 
or조건 이용(union all로 대체)
중복된 데이터가 많을때 안좋으니 넣지 말 것

손익분기점 
테이블이 가지고있는 전체 데이터량이 10에서 15퍼센트 정도 될 때 빠르다

인덱스의 장점
검색 속도가 빨라진다(항상 그런것 만은 아니다)
쿼리 부하가 줄어들어서 시스템 전체의 성능이 향상

인덱스의 단점
인덱스 오브젝트가 저장공간을 차지하는데 10% 정도의 디스크 공간이 더 필요하다
인덱스 생성시 시간이 걸릴 수 있다
insert update가 자주 일어나면 시간이 더 걸릴 수도 있다

4. 데이터베이스 논리적 저장 단계

블록 block
오라클 데이터베이스 저장의 최소단계
select 를 할때 데이터에 Input Output 하는 가장 작은 단위

익스텐트 extent
블록의 집합. 세그먼트 크기가 커질수록 인스텐트 증가
(데이터베이스가 공간을 할당)하는 가장 작은 단위
테이블에서 데이터를 쌓다가 저장공간이 부족해지면 하나의 익스텐트를 데이터베이스가 할당

세그먼트 segment
익스턴트가 모여서 세그먼트를 이룬다
저장공간을 갖는 오브젝트(테이블, 인덱스)를 지칭

view와 synonym은 오브젝트이지만  저장공간을 갖지 않으므로 세그먼트는 아니다

테이블스페이스 tablespace
하나의 세그먼트를 포함한다
논리적인 저장공간
세그먼트를 담고있는 거대한 컨테이너

5. 클러스터링 펙터
인덱스를 써서 검색을 할 때 얼마나 많은 블럭들을 읽을지에 대한 지표
인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있느냐에 대한 정도를 나타냄
순서가 비슷할 경우 클러스터링 펙터가 좋고(로우를 읽어들일 때 블록에 엑세스 한 횟수가 낮음)
순서가 비슷하지 않을 경우 클러스터링 펙터가 나쁘다(로우를 읽어들일 때  블록에 엑세스 한 횟수가 많음)

인덱스와 테이블이 분리되어서 저장되어지는 분리형 테이블에서는
낮은 복잡도로 로우에 엑세스(적은 량의 블록에 엑세스) 하는것이 중요한데
이 지표를 클러스터링 펙터라고 한다

분리형 테이블은 데이터를 저장할 때, 여러 블록에 데이터를 저장하는데
인덱스 데이터와 테이블 로우의 위치가 얼마나 주변에 모여 있느냐에 따라
엑세스 효율은 커다란 영향을 받게 된다 

많은 로우를 엑세스하더라도 '적은 수의 블록에 엑세스 하게 하는것'이 핵심
숫자가 낮을수록 IO가 적게 발생하고 성능이 좋다는 의미

지금까지의 상황으로 보았을때 insert시 로우와 인덱스를 같이 입력하는 방식을 써야 할 듯

클러스터링 펙터 향상을 위해 인덱스 유지관리가 필요하며 테이블 재생성 재구성 작업을 해야 함(모든 인덱스를 대상으 로 하는 것은 바람직 하지 않음)


6. 클러스터링 테이블, 인덱스
클러스터링
테이블이나 인덱스와 같은 오브젝트이며 테이블의 상위개념이다
생성된 클러스터 오브젝트 내에 테이블이 생성됨
테이블이 없는 클러스터는 어떤 데이터도 입력 할 수 없으므로 무의미

클러스터링 테이블
어떤 정해진 컬럼값을 기준으로 동일한 값을 가진 하나 이상의 테이블의 로우를 같은 장소에 저장하는 물리적인 기법
하나 이상의 테이블에서 같은 값을 가진 로우를 모아 두었다는 것은 조인이 될 로우들이 이미 옆에 같이 있다는 것을 의미

클러스터링 인덱스
클러스터링 컬럼의 값 마다 하나의 인덱스 로우를 가진다
일반적인 데이터와는 달리 distinct되어 저장된다(중복제거)
영어사전과 같이 범위 검색을 


단일테이블 클러스터링
클러스터에 테이블이 하나만 존재

다중테이블 클러스터링
클러스터에 테이블이 여러개 존재(조인 상태로 저장)

장점
조인시 블록에 엑세스 하는 횟수가 감소하며(클러스터 라고 하는 위치에 저장되어 있기 때문에)
횟수가 감소함에 따라 클러스터링 펙터가 좋아진다

단점 
정해진 블록을 찾아 값을입력 하므로 dml 시 성능이 다소 떨어짐
발생 안하면 괜찮


클러스터링 테이블 실습

create table t_cluster_Test (
id number primary key,
name varchar(32)
)

insert into t_cluster_test values(2,'b');
insert into t_cluster_test values(2,'b');
insert into t_cluster_test values(3,'c');

create table t1_cluster_test(
id number,
email_address varchar(32),
constraint  fk_id foreign key (id) references t_cluster_test(id) ON DELETE CASCADE
)

insert into t1_cluster_Test values(1,'a@a.com');
insert into t1_cluster_Test values(2,'b@c.com');
insert into t1_cluster_Test values(3,'b@c.com');

create cluster C_cluster_test (id number);   
/* 클러스터 생성 생성시 키 컬럼으로 지정할 컬럼은 형을 맞춰 주어야 한다*/


create index C_cluster_test_idx on cluster C_cluster_test;
/*인덱스 생성*/


create table c_t_cluster_test cluster C_cluster_test(id) as select * from t_cluster_test;
create table c_t1_cluster_test cluster C_cluster_test(id) as select * from t1_cluster_test;
/* 클러스터 테이블 생성 c_cluster_test 에 기존 테이블 t_cluset_test와 t1_cluster_test를 담았다 (다중 테이블 클러스터) */


SELECT OWNER, TABLE_NAME FROM DBA_TABLES WHERE CLUSTER_NAME = 'c_cluster_test';

select t.id , t.name , t1.email_address from c_t_cluster_test t 
inner join c_t1_cluster_test t1
on t.id = t1.id;
/*
	클러스터 테이블 생성 확인은 할 수 없었다.. scott계정에서 실행해 줘서 그런건지?
	sql developer 기준 테이블 세부정보에서 cluster_owner에 scott이라고 표시해주었으니 그걸로 다행인가 싶기도하고
*/
