1. 옵티마이저
sql을 실행할 최적의 경로를 생성해 주는 DBMS내부 엔진

2. 실행계획
sql을 실행할때 옵티마이저가 수립하는 작업의 절차
테이블 검색할때 어떤 식으로 검색을 할건지 인덱스 스캔을 할건지 안할건지 그런거 보여줌

3. 인덱스
테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터 베이스 객체(object)
키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능
색인(책 뒤에 찾아보기 개념)

비 트리 인덱스 보통 이것을 사용
비트맵 인덱스
iot 인덱스

클러스터형 인덱스 -> 영어사전같은 개념 (primary key 설정 시 자동으로 만들어짐) -> 범위 검색에 좋다 -> 영어사전 개념임

인덱스도 오브젝트이고
테이블과 매핑된 또다른 오브젝트가 생성된다

인덱스 저장방식은 인덱스 컬럼 기준으로 소팅이 되어서 생성된
인덱스는 '정렬'되어서 저장이 됨 -> 클러스터형 인덱스

인덱스에서 먼저 해당 데이터를 찾은 다음에 실제 매핑된  테이블에 엑세스 해서 데이터들을 찾음
(책 뒤에 찾아보기 개념)

특정 조건의 시작점을 인덱스로 검색하여 거기서부터 검색 

인덱스는 해당 데이터 블록의 주소(ROWID)를 가지고있다
블럭 => 데이터가 저장되는 최소방식, 테이블의 데이터들이 로우 단위으로 저장되어있음

특정 조건 즉 where 절에 등장하는 컬럼을 설정
order by -> 인덱스는 순차적으로 저장되기 때문에 

insert 나 update에서 속도가 느려질 수 있으므로 주의
순차적으로 입력된 데이터라서 그렇고
인덱스는 테이블과 매핑이 되어 있기 때문에 속도가 느릴 수 있다

인덱스 컬럼을 가공(함수이용)하면 인덱스를 사용안한다
인덱스 컬럼의 형변환 하면 인덱스를 사용 안한다 (같은 타입으로 비교)
null값에 대해서 찾는것도 인덱스를 사용 안한다
like연산 시 %가 앞에 위치한것
부정형 비교 != 
or조건 이용(union all로 대체)

중복된 데이터가 많을때 안좋으니 넣지 말 것

손익분기점 
테이블이 가지고있는 전체 데이터량이 10에서 15퍼센트 정도 될 때 빠르다

인덱스의 장점
검색 속도가 빨라진다(항상 그런것 만은 아니다)
쿼리 부하가 줄어들어서 시스템 전체의 성능이 향상

인덱스의 단점
인덱스 오브젝트가 저장공간을 차지하는데 10% 정도의 디스크 공간이 더 필요하다
인덱스 생성시 시간이 걸릴 수 있다
insert update가 자주 일어나면 시간이 더 걸릴 수도 있다



4. 데이터베이스 논리적 저장 단계

블록 block
오라클 데이터베이스 저장의 최소단계
select 를 할때 데이터에 Input Output 하는 가장 작은 단위

익스텐트 extent
블록의 집합. 세그먼트 크기가 커질수록 인스텐트 증가
(데이터베이스가 공간을 할당)하는 가장 작은 단위
테이블에서 데이터를 쌓다가 저장공간이 부족해지면 하나의 익스텐트를 데이터베이스가 할당

세그먼트 segment
익스턴트가 모여서 세그먼트를 이룬다
저장공간을 갖는 오브젝트(테이블, 인덱스)를 지칭

view와 synonym은 오브젝트이지만  저장공간을 갖지 않으므로 세그먼트는 아니다

테이블스페이스 tablespace
하나의 세그먼트를 포함한다
논리적인 저장공간
세그먼트를 담고있는 거대한 컨테이너

5. 클러스터링 펙터
데이터 저장순번과 인덱스의 저장순번이 얼마나 비슷한지를 표현한 지표
순서가 비슷할 경우 클러스터링 펙터가 좋고
순서가 비슷하지 않을 경우 클러스터링 펙터가 나쁘다

인덱스와 테이블이 분리되어서 저장되어지는 분리형 테이블에서는
낮은 복잡도로 로우에 엑세스(적은 량의 블록에 엑세스) 하는것이 중요한데
이 지표를 클러스터링 펙터라고 한다

분리형 테이블은 데이터를 저장할 때, 여러 블록에 데이터를 저장하는데
인덱스 데이터와 테이블 로우의 위치가 얼마나 주변에 모여 있느냐에 따라
엑세스 효율은 커다란 영향을 받게 된다 

많은 로우를 엑세스 하더라고 적은 수의 블록에 엑세스 하게 하는것이 핵심
숫자가 낮을수록 IO가 적게 발생하고 성능이 좋다는 의미

지금까지의 상황으로 보았을때 insert시 로우와 인덱스를 같이 입력하는 방식을 써야 할 듯


